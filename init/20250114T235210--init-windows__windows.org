#+title:      init-windows
#+date:       [2025-01-14 Tue 23:52]
#+filetags:   :windows:
#+identifier: 20250114T235210

* tangle
:PROPERTIES:
:CUSTOM_ID: f821084b-cde6-4f20-b2c6-653052a03c34
:END:
#+begin_src elisp
(make-directory "_tangle" t)
(let (org-confirm-babel-evaluate
      (zr-local-pls (plstore-open "init.pls")))
  (org-babel-tangle nil nil "^bat$")
  (let ((coding-system-for-write 'utf-8-with-signature))
    (org-babel-tangle nil nil "^powershell$")))
#+end_src

* profile
:PROPERTIES:
:header-args:bat: :tangle (zr-org-by-tangle-dir "profile.cmd")
:CUSTOM_ID: d961cb32-f35a-4e8e-99f0-bcd5edf4267b
:END:

#+begin_src bat :prologue :epilogue
@echo off
SETLOCAL

call :profile_main %1
#+end_src

** sub

*** misc
:PROPERTIES:
:header-args:bat+: :prologue (format ":%s" (org-element-property :name (org-element-at-point-no-context))) :epilogue "goto :eof"
:CUSTOM_ID: 66e3faf0-2247-4c25-b9ee-1d68a0b24f54
:END:
#+name: wait_seconds
#+begin_src bat 
timeout /t %1 /nobreak >nul 2>&1
#+end_src

#+name: set_rclone_env
#+begin_src bat :var rclone-user=(plist-get (cdr (plstore-get zr-local-pls "rclone")) :user) rclone-pass=(plist-get (cdr (plstore-get zr-local-pls "rclone")) :pass) rclone-addr=(plist-get (cdr (plstore-get zr-local-pls "rclone")) :addr)
#+end_src

#+name: kill_rclone
#+begin_src bat
call :set_rclone_env
curl "-u%rclone-user%:%rclone-pass%" -XPOST "http://%rclone-addr%/core/quit"
#+end_src

#+name: kill_process
#+begin_src bat
taskkill /f /im %1 >nul 2>&1
#+end_src

#+name: run_git_pull
#+begin_src bat
start /b git -C %1 pull --no-edit
#+end_src

#+name: check-prog
#+begin_src org :var program="emacs"
where $program >nul 2>&1
if errorlevel 1 (
  echo "$program not found"
  ENDLOCAL
  goto :eof
)
#+end_src

*** proc
:PROPERTIES:
:header-args:bat+: :prologue (format ":%s\nSETLOCAL" (org-element-property :name (org-element-at-point-no-context))) :epilogue "ENDLOCAL\ngoto :eof"
:CUSTOM_ID: c0ee49e0-fc37-4a12-9412-d54686aaca83
:END:
#+name: run_emacs
#+begin_src bat :var initd=(expand-file-name "../../.emacs.d") profileel=(zr-org-by-tangle-dir "profile.el")
cd %USERPROFILE%
del "%APPDATA%\.emacs.d\server\server"
start /b emacs.exe --daemon "--init-directory=%initd%" -l "%profileel%" -l "org-protocol"
#+end_src

#+name: run_rclone
#+begin_src bat
<<check-prog(program="rclone")>>
call :set_rclone_env
start /b rclone rcd "--rc-serve" "--rc-serve-no-modtime" "--rc-user=%rclone-user%" "--rc-pass=%rclone-pass%" "--rc-addr=%rclone-addr%" --no-console
#+end_src

#+name: run_ahk
#+begin_src bat :var ahk-script=(expand-file-name "../ahk/_tangle/default.ahk")
<<check-prog(program="autohotkey")>>
start /b autohotkey /script "%ahk-script%"
#+end_src

#+name: run_gpg_agent
#+begin_src bat
<<check-prog(program="gpgconf")>>
start /b gpgconf.exe --launch gpg-agent
#+end_src

#+name: run_aria2c
#+begin_src bat :var dir=(expand-file-name "../aria2/_tangle")
<<check-prog(program="aria2c")>>
all_proxy=http://127.0.0.1:10807
start /b /d "%dir%" /abovenormal aria2c.exe --conf-path aria2.conf
#+end_src

#+name: run_onedrive
#+begin_src bat
start /d "%USERPROFILE%\AppData\Local\Microsoft\OneDrive" OneDrive.exe /background
#+end_src

#+name: run_openresty
#+begin_src bat
<<check-prog(program="openresty")>>
start /b openresty -p %USERPROFILE%\scoop\apps\openresty\current
#+end_src

#+name: run_caddy
#+header: :var config=(expand-file-name "../caddy/_tangle/Caddyfile")
#+header: :var env=(expand-file-name "../caddy/_tangle/env")
#+begin_src bat
<<check-prog(program="caddy")>>
caddy start --config "%config%" --envfile "%env%"
#+end_src

#+name: run_alist
#+begin_src bat :var no_proxy=(concat (getenv "no_proxy") ",.alipan.com,.aliyundrive.net")
<<check-prog(program="alist")>>
start /b alist server
#+end_src

#+name: run_mpd
#+begin_src bat
<<check-prog(program="mpd")>>
start /b mpd "%USERPROFILE%\scoop\persist\mpd\mpd.conf"
#+end_src

#+name: run_sing_box
#+begin_src bat :var config=(expand-file-name "../sing-box/_tangle/client/500-main.json")
start /b sing-box run -c "%config%"
#+end_src

#+name: run_naive
#+begin_src bat :var config=(expand-file-name "../sing-box/_tangle/naive/vps0")
start /b naive "%config%"
#+end_src

**** trojan
:PROPERTIES:
:header-args+: :var trojan-dir=(concat (getenv "USERPROFILE") "\\scoop\\app\\trojan-go")
:CUSTOM_ID: 2374627e-d10d-46d4-8ff7-6f1d9d9a7b63
:END:

#+begin_src elisp :tangle (zr-org-by-tangle-dir "profile.el") :mkdirp t
(ignore-errors
  (delete-file (expand-file-name "trojan.log" trojan-dir) t)
  (dolist (f (directory-files-recursively
              (substitute-in-file-name "$USERPROFILE/AppData/Roaming/Tencent/QQ/AuTemp/")
              (rx bos "cfg.db" eos)))
    (rename-file f (file-name-with-extension f "bak") t))
  (delete-file (substitute-in-file-name "$USERPROFILE/ansel/tmp")))
#+end_src

#+name: run_trojan
#+begin_src bat :var config=(expand-file-name "../trojan-go/_tangle/config.json")
start /b /abovenormal /d "%trojan-dir%" trojan-go.exe -config "%config%"
#+end_src

** main
:PROPERTIES:
:CUSTOM_ID: 9376588a-03e6-48d7-b125-fe4025b5d1f5
:END:
#+name: profile_main
#+begin_src bat :prologue (format ":%s\nSETLOCAL" (org-element-property :name (org-element-at-point-no-context))) :epilogue :var git_pull_dir_1=(expand-file-name "../../.emacs.d") git_pull_dir_2=(expand-file-name "../../.config")
set "arg=%1"

if /i "%arg%"=="emacs" (
    call :kill_process emacs.exe
    call :wait_seconds 1
    call :run_emacs
) else if /i "%arg%"=="ahk" (
    call :kill_process autohotkeyux.exe
    call :wait_seconds 1
    call :run_ahk
) else if /i "%arg%"=="trojan-go" (
    call :kill_process trojan-go.exe
    call :wait_seconds 1
    call :run_trojan
) else if /i "%arg%"=="sing-box" (
    call :kill_process sing-box.exe
    call :wait_seconds 1
    call :run_sing_box
) else if /i "%arg%"=="caddy" (
    caddy stop
    call :wait_seconds 1
    call :run_caddy
) else if /i "%arg%"=="naive" (
    call :kill_process naive.exe
    call :wait_seconds 1
    call :run_naive
) else if /i "%arg%"=="alist" (
    call :kill_process alist.exe
    call :wait_seconds 1
    call :run_alist
) else if /i "%arg%"=="rclone" (
    call :kill_rclone
    call :wait_seconds 3
    call :run_rclone
) else if /i "%arg%"=="aria2" (
    call :kill_process aria2c.exe
    call :wait_seconds 1
    call :run_aria2c
) else if /i "%arg%"=="init" (
    call :run_emacs
    call :wait_seconds 1
    call :run_rclone
    call :wait_seconds 1
    call :run_ahk
    call :wait_seconds 2
    rem call :run_trojan
    call :run_sing_box
    call :wait_seconds 3
    call :run_gpg_agent
    call :wait_seconds 3
    call :run_aria2c
    call :wait_seconds 3
    call :run_git_pull %git_pull_dir_1%
    call :wait_seconds 3
    call :run_onedrive
    call :wait_seconds 3
    rem call :run_openresty
    call :run_caddy
    call :wait_seconds 3
    call :run_alist
    call :wait_seconds 3
    call :run_mpd
    call :wait_seconds 3
    call :run_git_pull %git_pull_dir_2%
    call :wait_seconds 3
    call :run_naive
) else (
  echo "Please give an valid argument."
)

ENDLOCAL
#+end_src

* Scripts
:PROPERTIES:
:CUSTOM_ID: e56356f4-7700-435b-b354-55e246a3b53b
:END:

** Toggle-WindowsUpdate
:PROPERTIES:
:CUSTOM_ID: eaa546a8-f4e2-4173-9e95-ee60389fcfaa
:END:
#+begin_src powershell :comments no :tangle (zr-org-by-tangle-dir "toggle-windows-update.ps1")
#Requires -RunAsAdministrator

param (
    [ValidateSet("Suspend", "Resume")]
    [string]$Action,
    [int]$Weeks
)

# 注册表路径
$regPath = "HKLM:\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings"

# 显示通知函数
function Show-Notification {
    param(
        [string]$Title,
        [string]$Message,
        [string]$ActionText = "打开更新设置"
    )
    
    try {
        Add-Type -AssemblyName System.Windows.Forms
        
        # 创建NotifyIcon
        $balloon = New-Object System.Windows.Forms.NotifyIcon
        $balloon.Icon = [System.Drawing.SystemIcons]::Information
        $balloon.BalloonTipTitle = $Title
        $balloon.BalloonTipText = $Message
        $balloon.BalloonTipIcon = "Info"
        $balloon.Visible = $true
        
        # 显示通知
        $balloon.ShowBalloonTip(10000) # 显示10秒
        
        # 点击事件
        $balloon.Add_BalloonTipClicked({
            Start-Process "ms-settings:windowsupdate"
        })
        
        # 10秒后自动关闭
        $job = Start-Job -ScriptBlock {
            param($balloonPath)
            Start-Sleep -Seconds 10
            if (Test-Path $balloonPath) {
                $balloon = Get-Item $balloonPath | Import-Clixml
                if ($balloon -and $balloon.Visible) {
                    $balloon.Dispose()
                }
            }
        } -ArgumentList "$env:TEMP\balloon.xml"
        
        # 保存NotifyIcon对象以便后台作业访问
        $balloon | Export-Clixml -Path "$env:TEMP\balloon.xml"
        
        return
    }
    catch {
        Write-Warning "通知显示失败: $_"
    }
}

# 检查当前更新状态
function Check-UpdateStatus {
    $pauseUpdates = Get-ItemProperty -Path $regPath -Name "PauseUpdatesExpiryTime" -ErrorAction SilentlyContinue
    
    if ($pauseUpdates) {
        $expiryTime = [DateTime]::Parse($pauseUpdates.PauseUpdatesExpiryTime)
        $currentTime = Get-Date
        
        if ($expiryTime -gt $currentTime) {
            $daysRemaining = ($expiryTime - $currentTime).Days
            Write-Host "Windows更新已暂停，将在 $daysRemaining 天后恢复。" -ForegroundColor Yellow
            return $true
        } else {
            Write-Host "Windows更新暂停已过期。" -ForegroundColor Red
            return $false
        }
    } else {
        Write-Host "Windows更新当前处于活动状态。" -ForegroundColor Green
        return $false
    }
}

# 暂停更新
function Suspend-Updates {
    param(
        [int]$weeks = 1000
    )
    
    $startTime = Get-Date
    $endTime = $startTime.AddDays($weeks * 7)
    
    # 格式化为ISO 8601格式
    $startTimeStr = $startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
    $endTimeStr = $endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
    
    # 设置注册表值
    Set-ItemProperty -Path $regPath -Name "PauseFeatureUpdatesStartTime" -Value $startTimeStr -Type String -Force
    Set-ItemProperty -Path $regPath -Name "PauseFeatureUpdatesEndTime" -Value $endTimeStr -Type String -Force
    Set-ItemProperty -Path $regPath -Name "PauseQualityUpdatesStartTime" -Value $startTimeStr -Type String -Force
    Set-ItemProperty -Path $regPath -Name "PauseQualityUpdatesEndTime" -Value $endTimeStr -Type String -Force
    Set-ItemProperty -Path $regPath -Name "PauseUpdatesStartTime" -Value $startTimeStr -Type String -Force
    Set-ItemProperty -Path $regPath -Name "PauseUpdatesExpiryTime" -Value $endTimeStr -Type String -Force
    
    Write-Host "Windows更新已暂停 $weeks 周，将于 $endTime 恢复。" -ForegroundColor Yellow
    
    # 显示通知
    Show-Notification -Title "Windows更新已暂停" -Message "更新已暂停 $weeks 周，将于 $endTime 恢复。"
}

# 恢复更新
function Resume-Updates {
    # 删除暂停相关的注册表项
    $pauseKeys = @(
        "PauseFeatureUpdatesStartTime",
        "PauseFeatureUpdatesEndTime",
        "PauseQualityUpdatesStartTime",
        "PauseQualityUpdatesEndTime",
        "PauseUpdatesStartTime",
        "PauseUpdatesExpiryTime"
    )
    
    foreach ($key in $pauseKeys) {
        Remove-ItemProperty -Path $regPath -Name $key -ErrorAction SilentlyContinue -Force
    }
    
    Write-Host "Windows更新已恢复。" -ForegroundColor Green
    
    # 显示通知
    Show-Notification -Title "Windows更新已恢复" -Message "Windows更新已恢复。"
}

# 主程序逻辑
$isPaused = Check-UpdateStatus

# 处理命令行参数
if ($Action -eq "Resume") {
    # 明确要求恢复更新
    Resume-Updates
}
elseif ($Weeks -gt 0) {
    # 指定了暂停周数，无论当前状态如何都重新设置暂停时间
    Suspend-Updates -weeks $Weeks
}
elseif ($Action -eq "Suspend") {
    # 明确要求暂停但未指定周数，使用默认
    Suspend-Updates
}
else {
    # 没有指定参数，根据当前状态自动决定
    if ($isPaused) {
        Resume-Updates
    } else {
        Suspend-Updates
    }
}

# 清理临时文件
if (Test-Path "$env:TEMP\balloon.xml") {
    Remove-Item "$env:TEMP\balloon.xml" -Force
}
#+end_src

** save-with-sudo
:PROPERTIES:
:CUSTOM_ID: b55d374f-2bac-42ad-8da5-55dc220d4ecf
:END:
#+begin_src powershell :tangle (zr-org-by-tangle-dir "save-with-sudo.ps1")
param(
    [string]$FilePath
)

# 处理管道输入或直接输入
if (Test-Path $FilePath) {
    $content = $input | Out-String
} else {
    Write-Error "No file path specified."
    exit 1
}

# 创建临时文件（在用户临时目录中）
$tempFile = [System.IO.Path]::GetTempFileName()

try {
    # 将内容写入临时文件
    Out-File -Encoding utf8 -FilePath "$tempFile" -InputObject "$content"

    # 备份权限
    $acl = Get-Acl $FilePath
    
    $cw = (Get-Location).Path
    sudo -D "$cw" mv -f "$tempFile" "$FilePath"
    
    # 检查执行结果
    if ($LASTEXITCODE -ne 0) {
        # 恢复权限
        Set-Acl $FilePath $acl

        Write-Error "Failed to save file with sudo. Exit code: $LASTEXITCODE"
        exit $LASTEXITCODE
    }
}
catch {
    Write-Error "Error occurred: $_"
    # 如果出错，保留临时文件以便恢复
    Write-Warning "Temporary file preserved at: $tempFile"
    exit 1
}
#+end_src

** skip-online-account
:PROPERTIES:
:CUSTOM_ID: 369095a1-aa9d-4009-9d67-87cb9480e60a
:END:
#+begin_src bat
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\OOBE /v BypassNRO /t REG_DWORD /d 1 /f shutdown /r /t 0
#+end_src

** Debug-Firewall
https://superuser.com/a/1141671
#+begin_src powershell :tangle (zr-org-by-tangle-dir "debug-firewall.ps1")
#Requires -RunAsAdministrator

<#
.SYNOPSIS
    Windows 防火墙调试自动化脚本
.DESCRIPTION
    自动化 Windows Filtering Platform (WFP) 调试流程，帮助定位阻止连接的防火墙规则
.NOTES
    需要管理员权限运行
    文件编码：UTF-8 with BOM（避免中文乱码）
    
    本脚本使用 GUID 而非名称调用 auditpol 命令，确保在所有语言版本的 Windows 上都能正常工作：
    - {0CCE9225-69AE-11D9-BED3-505054503030} = Filtering Platform Packet Drop
    - {0CCE9226-69AE-11D9-BED3-505054503030} = Filtering Platform Connection
#>

[CmdletBinding()]
param()

# 颜色输出函数
function Write-ColorOutput {
    param(
        [string]$Message,
        [string]$ForegroundColor = "White"
    )
    Write-Host $Message -ForegroundColor $ForegroundColor
}

# 显示菜单
function Show-Menu {
    Clear-Host
    Write-ColorOutput "`n==================== Windows 防火墙调试工具 ====================" "Cyan"
    Write-ColorOutput "`n请选择操作：" "Yellow"
    Write-ColorOutput "1. 启用防火墙审计 (开始调试)" "Green"
    Write-ColorOutput "2. 生成 WFP 状态文件 (重现问题后执行)" "Green"
    Write-ColorOutput "3. 打开事件查看器 (查找被阻止的数据包)" "Green"
    Write-ColorOutput "4. 搜索 Filter ID (在 XML 文件中查找规则名称)" "Green"
    Write-ColorOutput "5. 关闭防火墙审计 (完成调试)" "Red"
    Write-ColorOutput "6. 完整调试流程 (交互式引导)" "Magenta"
    Write-ColorOutput "7. 查看当前审计状态" "Cyan"
    Write-ColorOutput "0. 退出" "Gray"
    Write-ColorOutput "`n===============================================================" "Cyan"
}

# 启用审计
function Enable-FirewallAudit {
    Write-ColorOutput "`n[步骤 1/7] 启用 Windows Filtering Platform 审计..." "Yellow"
    
    # 使用 GUID 避免多语言问题
    # {0CCE9225-69AE-11D9-BED3-505054503030} = Filtering Platform Packet Drop
    # {0CCE9226-69AE-11D9-BED3-505054503030} = Filtering Platform Connection
    
    try {
        Write-ColorOutput "启用 'Filtering Platform Packet Drop' 审计..." "Gray"
        auditpol /set /subcategory:"{0CCE9225-69AE-11D9-BED3-505054503030}" /success:enable /failure:enable
        
        Write-ColorOutput "启用 'Filtering Platform Connection' 审计..." "Gray"
        auditpol /set /subcategory:"{0CCE9226-69AE-11D9-BED3-505054503030}" /success:enable /failure:enable
        
        Write-ColorOutput "`n✓ 审计已成功启用！" "Green"
        Write-ColorOutput "注意：这可能会产生大量事件日志数据" "Yellow"
    }
    catch {
        Write-ColorOutput "`n✗ 启用审计失败: $_" "Red"
    }
}

# 关闭审计
function Disable-FirewallAudit {
    Write-ColorOutput "`n[步骤 7/7] 关闭 Windows Filtering Platform 审计..." "Yellow"
    
    # 使用 GUID 避免多语言问题
    # {0CCE9225-69AE-11D9-BED3-505054503030} = Filtering Platform Packet Drop
    # {0CCE9226-69AE-11D9-BED3-505054503030} = Filtering Platform Connection
    
    try {
        Write-ColorOutput "关闭 'Filtering Platform Packet Drop' 审计..." "Gray"
        auditpol /set /subcategory:"{0CCE9225-69AE-11D9-BED3-505054503030}" /success:disable /failure:disable
        
        Write-ColorOutput "关闭 'Filtering Platform Connection' 审计..." "Gray"
        auditpol /set /subcategory:"{0CCE9226-69AE-11D9-BED3-505054503030}" /success:disable /failure:disable
        
        Write-ColorOutput "`n✓ 审计已成功关闭！" "Green"
    }
    catch {
        Write-ColorOutput "`n✗ 关闭审计失败: $_" "Red"
    }
}

# 生成 WFP 状态文件
function Export-WFPState {
    Write-ColorOutput "`n[步骤 3/7] 生成 WFP 状态文件..." "Yellow"
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $outputFile = "wfpstate_$timestamp.xml"
    
    try {
        Write-ColorOutput "正在导出 WFP 状态到 $outputFile ..." "Gray"
        
        # 执行 netsh 命令并隐藏输出（命令会自动生成 wfpstate.xml 文件）
        $netshOutput = netsh wfp show state 2>&1 | Out-String
        
        # 显示 netsh 命令的状态消息（如果有）
        if ($netshOutput -and $netshOutput.Trim()) {
            Write-ColorOutput "netsh 输出: $($netshOutput.Trim())" "Gray"
        }
        
        # 等待文件生成（有时需要短暂延迟）
        Start-Sleep -Milliseconds 500
        
        # 查找生成的文件
        $generatedFile = Get-ChildItem -Path . -Filter "wfpstate.xml" -ErrorAction SilentlyContinue | Select-Object -First 1
        
        if ($generatedFile) {
            # 重命名为带时间戳的文件名
            Rename-Item -Path $generatedFile.FullName -NewName $outputFile -Force
            Write-ColorOutput "`n✓ WFP 状态文件已生成: $outputFile" "Green"
            Write-ColorOutput "文件位置: $(Get-Location)\$outputFile" "Cyan"
            return $outputFile
        }
        else {
            Write-ColorOutput "`n✗ 未找到生成的 wfpstate.xml 文件" "Red"
            return $null
        }
    }
    catch {
        Write-ColorOutput "`n✗ 生成 WFP 状态文件失败: $_" "Red"
        return $null
    }
}

# 打开事件查看器
function Open-EventViewer {
    Write-ColorOutput "`n[步骤 4/7] 打开事件查看器..." "Yellow"
    
    try {
        Start-Process eventvwr.msc
        Write-ColorOutput "`n✓ 事件查看器已打开" "Green"
        Write-ColorOutput "`n请按以下步骤操作：" "Cyan"
        Write-ColorOutput "1. 导航到 'Windows 日志' > '安全'" "White"
        Write-ColorOutput "2. 在右侧菜单使用 '查找' 功能" "White"
        Write-ColorOutput "3. 搜索与您的问题相关的项目（源 IP、目标端口等）" "White"
        Write-ColorOutput "4. 找到被丢弃的数据包日志" "White"
        Write-ColorOutput "5. 在日志详细信息中向下滚动，记录 Filter ID" "White"
    }
    catch {
        Write-ColorOutput "`n✗ 打开事件查看器失败: $_" "Red"
    }
}

# 搜索 Filter ID
function Search-FilterID {
    param(
        [string]$XmlFile = "",
        [string]$FilterID = ""
    )
    
    Write-ColorOutput "`n[步骤 5-6/7] 在 XML 文件中搜索 Filter ID..." "Yellow"
    
    # 如果没有提供 XML 文件，列出当前目录的 XML 文件
    if ([string]::IsNullOrEmpty($XmlFile)) {
        $xmlFiles = Get-ChildItem -Path . -Filter "wfpstate*.xml" | Sort-Object LastWriteTime -Descending
        
        if ($xmlFiles.Count -eq 0) {
            Write-ColorOutput "`n✗ 当前目录没有找到 wfpstate*.xml 文件" "Red"
            Write-ColorOutput "提示：请先执行选项 2 生成 WFP 状态文件" "Yellow"
            return
        }
        
        Write-ColorOutput "`n找到以下 XML 文件：" "Cyan"
        for ($i = 0; $i -lt $xmlFiles.Count; $i++) {
            Write-ColorOutput "$($i + 1). $($xmlFiles[$i].Name) (修改时间: $($xmlFiles[$i].LastWriteTime))" "White"
        }
        
        $fileChoice = Read-Host "`n请选择文件编号 (直接回车使用最新的)"
        
        if ([string]::IsNullOrEmpty($fileChoice)) {
            $XmlFile = $xmlFiles[0].FullName
        }
        else {
            $index = [int]$fileChoice - 1
            if ($index -ge 0 -and $index -lt $xmlFiles.Count) {
                $XmlFile = $xmlFiles[$index].FullName
            }
            else {
                Write-ColorOutput "✗ 无效的选择" "Red"
                return
            }
        }
    }
    
    # 如果没有提供 Filter ID，提示输入
    if ([string]::IsNullOrEmpty($FilterID)) {
        $FilterID = Read-Host "`n请输入要搜索的 Filter ID"
    }
    
    if ([string]::IsNullOrEmpty($FilterID)) {
        Write-ColorOutput "✗ Filter ID 不能为空" "Red"
        return
    }
    
    try {
        Write-ColorOutput "`n正在搜索 Filter ID: $FilterID ..." "Gray"
        Write-ColorOutput "文件路径: $XmlFile" "Gray"
        
        # 检查文件是否存在
        if (-not (Test-Path $XmlFile)) {
            Write-ColorOutput "`n✗ 文件不存在: $XmlFile" "Red"
            return
        }
        
        # 获取文件大小
        $fileSize = (Get-Item $XmlFile).Length / 1MB
        Write-ColorOutput "文件大小: $([math]::Round($fileSize, 2)) MB" "Gray"
        
        # 读取 XML 文件
        Write-ColorOutput "正在加载 XML 文件..." "Gray"
        
        $xmlContent = $null
        $loadSuccess = $false
        
        # 方法1: 直接加载（适用于标准 XML）
        try {
            $xmlContent = New-Object System.Xml.XmlDocument
            $xmlContent.Load($XmlFile)
            $loadSuccess = $true
            Write-ColorOutput "✓ XML 加载成功（使用 XmlDocument.Load 方法）" "Gray"
        }
        catch {
            Write-ColorOutput "⚠ 方法1失败: $_" "Yellow"
            Write-ColorOutput "⚠ 检测到多根元素 XML（netsh wfp 文件的常见问题），尝试特殊处理..." "Yellow"
            
            # 方法2: 处理多根元素 XML（netsh wfp show state 生成的文件特有问题）
            try {
                $xmlString = Get-Content -Path $XmlFile -Encoding UTF8 -Raw
                
                # 移除原始的 XML 声明（如果存在）
                $xmlString = $xmlString -replace '^\s*<\?xml[^>]+\?>\s*', ''
                
                # 包装在单个根元素中
                $wrappedXml = "<?xml version=`"1.0`" encoding=`"UTF-8`"?>`n<root>`n$xmlString`n</root>"
                
                $xmlContent = New-Object System.Xml.XmlDocument
                $xmlContent.LoadXml($wrappedXml)
                $loadSuccess = $true
                Write-ColorOutput "✓ XML 加载成功（使用特殊处理多根元素）" "Gray"
                Write-ColorOutput "说明: netsh wfp 生成的文件包含多个根元素，已自动修正" "Gray"
            }
            catch {
                Write-ColorOutput "✗ XML 加载失败: $_" "Red"
                Write-ColorOutput "⚠ 尝试使用文本搜索模式..." "Yellow"
                $loadSuccess = $false
            }
        }
        
        if (-not $loadSuccess) {
            Write-ColorOutput "✗ 无法加载 XML 文件" "Red"
            return
        }
        
        # 搜索包含 Filter ID 的节点
        Write-ColorOutput "正在搜索节点..." "Gray"
        $filters = $xmlContent.SelectNodes("//*[contains(., '$FilterID')]")
        
        if ($filters.Count -eq 0) {
            Write-ColorOutput "`n✗ 未找到 Filter ID: $FilterID" "Red"
            Write-ColorOutput "提示: 请确认 Filter ID 是否正确" "Yellow"
            return
        }
        
        Write-ColorOutput "`n✓ 找到 $($filters.Count) 个匹配项：" "Green"
        
        $matchCount = 0
        foreach ($filter in $filters) {
            $matchCount++
            Write-ColorOutput "`n--- 匹配项 #$matchCount ---" "Cyan"
            
            # 尝试获取 displayData/name
            $nameNode = $filter.SelectSingleNode(".//displayData/name")
            if ($nameNode) {
                Write-ColorOutput "规则名称: $($nameNode.InnerText)" "Cyan"
            }
            
            # 尝试获取 filterId
            $filterIdNode = $filter.SelectSingleNode(".//filterId")
            if ($filterIdNode) {
                Write-ColorOutput "Filter ID: $($filterIdNode.InnerText)" "White"
            }
            
            # 尝试获取 layerKey
            $layerKeyNode = $filter.SelectSingleNode(".//layerKey")
            if ($layerKeyNode) {
                Write-ColorOutput "Layer Key: $($layerKeyNode.InnerText)" "Gray"
            }
            
            # 显示节点的部分内容
            $nodeText = $filter.OuterXml
            if ($nodeText.Length -gt 500) {
                $nodeText = $nodeText.Substring(0, 500) + "..."
            }
            Write-ColorOutput "`nXML 片段:" "Gray"
            Write-ColorOutput $nodeText "White"
            Write-ColorOutput ("-" * 80) "Gray"
        }
        
        # 提供更详细的搜索选项
        $detailed = Read-Host "`n是否要将所有匹配的完整 XML 内容保存到文件? (Y/N)"
        if ($detailed -eq 'Y' -or $detailed -eq 'y') {
            $outputFile = "filter_${FilterID}_details.xml"
            $filters | ForEach-Object { $_.OuterXml } | Out-File -FilePath $outputFile -Encoding UTF8
            Write-ColorOutput "✓ 详细信息已保存到: $outputFile" "Green"
            Write-ColorOutput "文件位置: $(Get-Location)\$outputFile" "Cyan"
        }
    }
    catch {
        Write-ColorOutput "`n✗ 搜索失败: $_" "Red"
        Write-ColorOutput "错误详情: $($_.Exception.Message)" "Yellow"
        Write-ColorOutput "堆栈跟踪: $($_.ScriptStackTrace)" "Gray"
    }
}

# 查看审计状态
function Get-AuditStatus {
    Write-ColorOutput "`n查看当前审计状态..." "Yellow"
    
    # 使用 GUID 避免多语言问题
    # {0CCE9225-69AE-11D9-BED3-505054503030} = Filtering Platform Packet Drop
    # {0CCE9226-69AE-11D9-BED3-505054503030} = Filtering Platform Connection
    
    try {
        Write-ColorOutput "`n当前审计策略：" "Cyan"
        auditpol /get /subcategory:"{0CCE9225-69AE-11D9-BED3-505054503030}","{0CCE9226-69AE-11D9-BED3-505054503030}"
        
        Write-ColorOutput "`n说明：使用 GUID 查询，兼容所有语言版本的 Windows" "Gray"
    }
    catch {
        Write-ColorOutput "`n✗ 获取审计状态失败: $_" "Red"
    }
}

# 完整调试流程
function Start-FullDebugWorkflow {
    Write-ColorOutput "`n==================== 完整调试流程 ====================" "Magenta"
    
    # 步骤 1: 启用审计
    Enable-FirewallAudit
    Read-Host "`n按回车继续..."
    
    # 步骤 2: 提示重现问题
    Write-ColorOutput "`n[步骤 2/7] 重现问题" "Yellow"
    Write-ColorOutput "请执行导致连接被阻止的操作（例如：访问特定网址、运行特定应用等）" "Cyan"
    Read-Host "完成后按回车继续..."
    
    # 步骤 3: 生成 WFP 状态文件
    $xmlFile = Export-WFPState
    
    # 步骤 4: 询问是否关闭审计（数据收集完成）
    Write-ColorOutput "`n[步骤 4/7] 关闭防火墙审计" "Yellow"
    Write-ColorOutput "说明: WFP 状态文件和事件日志数据已收集完成" "Cyan"
    Write-ColorOutput "建议: 立即关闭审计以减少系统负载和日志量" "Yellow"
    $closeAuditNow = Read-Host "`n是否现在关闭防火墙审计? (Y/N，建议选择 Y)"
    
    if ($closeAuditNow -eq 'Y' -or $closeAuditNow -eq 'y') {
        Disable-FirewallAudit
        Write-ColorOutput "✓ 审计已关闭" "Green"
    }
    else {
        Write-ColorOutput "⚠ 审计仍在运行，请记得稍后手动关闭（选项 5）" "Yellow"
    }
    Read-Host "`n按回车继续..."
    
    # 步骤 5: 打开事件查看器
    Open-EventViewer
    Read-Host "`n按回车继续..."
    
    # 步骤 6: 搜索 Filter ID
    if ($xmlFile) {
        Search-FilterID -XmlFile $xmlFile
    }
    else {
        Search-FilterID
    }
    Read-Host "`n按回车继续..."
    
    # 完成
    Write-ColorOutput "`n==================== 调试流程已完成 ====================" "Green"
    Write-ColorOutput "✓ WFP 状态文件已生成" "Green"
    Write-ColorOutput "✓ 所有数据已收集并可供分析" "Green"
    
    # 提醒检查审计状态
    if ($closeAuditNow -ne 'Y' -and $closeAuditNow -ne 'y') {
        Write-ColorOutput "`n⚠ 提醒：防火墙审计仍在运行" "Yellow"
        Write-ColorOutput "请使用选项 5 或选项 7 检查并关闭审计" "Yellow"
    }
}

# 主程序
function Main {
    # 检查管理员权限
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
    if (-not $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-ColorOutput "✗ 此脚本需要管理员权限运行！" "Red"
        Write-ColorOutput "请右键单击 PowerShell 并选择 '以管理员身份运行'" "Yellow"
        Read-Host "按回车退出"
        exit
    }
    
    do {
        Show-Menu
        $choice = Read-Host "`n请输入选项"
        
        switch ($choice) {
            '1' {
                Enable-FirewallAudit
                Read-Host "`n按回车返回主菜单"
            }
            '2' {
                Export-WFPState
                Read-Host "`n按回车返回主菜单"
            }
            '3' {
                Open-EventViewer
                Read-Host "`n按回车返回主菜单"
            }
            '4' {
                Search-FilterID
                Read-Host "`n按回车返回主菜单"
            }
            '5' {
                Disable-FirewallAudit
                Read-Host "`n按回车返回主菜单"
            }
            '6' {
                Start-FullDebugWorkflow
                Read-Host "`n按回车返回主菜单"
            }
            '7' {
                Get-AuditStatus
                Read-Host "`n按回车返回主菜单"
            }
            '0' {
                Write-ColorOutput "`n感谢使用！再见！" "Cyan"
                break
            }
            default {
                Write-ColorOutput "`n✗ 无效的选项，请重新选择" "Red"
                Start-Sleep -Seconds 1
            }
        }
    } while ($choice -ne '0')
}

# 运行主程序
Main
#+end_src

* Custom

** Explorer Network Driver
:PROPERTIES:
:CUSTOM_ID: dfb6afbf-dc39-4afd-a5be-d9e935311654
:END:
#+begin_src bat :eval no
reg add HKLM\SYSTEM\CurrentControlSet\Services\WebClient\Parameters /v BasicAuthLevel /t reg_dword /d 2 /f
reg add HKLM\SYSTEM\CurrentControlSet\Services\WebClient\Parameters /v FileSizeLimitInBytes /t reg_dword /d 0xffffffff /f

net stop WebClient
net start WebClient

#+end_src

* Service
:PROPERTIES:
:CUSTOM_ID: 6645c844-7504-45d0-86b4-11de2bdd07ba
:END:
#+name: services
| name    | prog   | args                                                                                     | task-args |
|---------+--------+------------------------------------------------------------------------------------------+-----------|
| profile | wt.exe | (format "'-w' '_quake' '-p' 'Command Prompt' '%s'" (zr-org-by-tangle-dir "profile.cmd")) |           |

#+name: services-bak
| name  | prog           | args                                                                            | task-args |
|-------+----------------+---------------------------------------------------------------------------------+-----------|
| emacs | runemacs.exe   | (format "'--daemon' '--init-directory=%s'" (expand-file-name "../../.emacs.d")) |           |
| ahk   | autohotkey.exe | (format "'/script' '%s'" (expand-file-name "../ahk/default.ahk"))               |           |

#+begin_src elisp :var cmd=create-serv-cmd()
(let ((cmd-file (expand-file-name "_output/create-service.cmd")))
  (make-directory (file-name-directory cmd-file) t)
  (write-region cmd nil cmd-file)
  (kill-new cmd-file)
  (message "%s" "Please run the copied script."))
#+end_src

#+name: create-serv-cmd
#+begin_src elisp :var services=services[]
(mapconcat
 (lambda (s)
   (pcase-let ((`(,name ,prog ,args ,task-args) s))
     (unless (file-name-absolute-p prog)
       (setq prog (subst-char-in-string ?/ ?\\ (executable-find prog))))
     (when (string-match-p (rx bos ?( (+ anychar) ?) eos) args)
       (setq args (eval (car (read-from-string args)))))
     ;; <<env-call>>
     (format "C:\\Windows\\System32\\schtasks.exe /create /ru %s /it /sc onlogon /tn \"%s\" /tr \"'%s' %s\" %s"
             user-login-name name prog args task-args)))
 services "\n")
#+end_src

#+name: env-call
#+begin_src elisp :eval no
(when-let* ((env (executable-find "env")))
  (setq args (format "'-C' '%s' '%s' %s" (getenv "USERPROFILE") prog args)
        prog (subst-char-in-string ?/ ?\\ env)))
#+end_src
