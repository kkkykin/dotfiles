#+title:      uv
#+date:       [2025-07-09 Wed 16:48]
#+filetags:   :base:
#+identifier: 20250709T164836

* tangle
#+begin_src elisp
(let ((conf-path (pcase system-type
                   ('windows-nt (substitute-in-file-name "$APPDATA/uv/uv.toml"))
                   (_ (expand-file-name "~/.config/uv/uv.toml")))))
  (org-babel-tangle)
  (mkdir (file-name-directory conf-path) t)
  (make-symbolic-link (zr-org-by-tangle-dir "uv.toml") conf-path t))
#+end_src

* config
:PROPERTIES:
:CUSTOM_ID: d18cc652-cc91-4913-898d-b3be6afd5256
:END:
#+begin_src toml :mkdirp t :tangle (zr-org-by-tangle-dir "uv.toml")
[[index]]
url = "https://pypi.mirrors.ustc.edu.cn/simple/"
default = true
#+end_src

* scripts
:PROPERTIES:
:tangle-dir: _tangle/scripts
:header-args:py: :shebang "#!/usr/bin/env -S uv run --no-project -s"
:END:

** browser
:PROPERTIES:
:CUSTOM_ID: 0dc9436b-511b-441a-b051-ead342d8d286
:END:
#+begin_src py :mkdirp t :tangle (zr-org-by-tangle-dir "chrome_ctrl.py")
"""
chrome_ctrl.py
关闭与正则匹配的 Chrome 标签页
用法:
  python chrome_ctrl.py close '<regex>'
"""
import sys
import re
import json
import urllib.request as req
import urllib.error

DEBUG_PORT = 9222
DEBUG_URL = f"http://127.0.0.1:{DEBUG_PORT}"

def get_tabs():
  """返回 List[dict]，每个 dict 含 id / url / title 等字段"""
  try:
    with req.urlopen(f"{DEBUG_URL}/json/list", timeout=3) as resp:
      return json.loads(resp.read())
  except Exception as e:
    print("获取标签页失败:", e, file=sys.stderr)
    sys.exit(2)


def close_tab(tab_id):
  """调用 Chrome DevTools HTTP 接口关闭标签页"""
  url = f"{DEBUG_URL}/json/close/{tab_id}"
  try:
    req.urlopen(url, timeout=3).read()
  except urllib.error.HTTPError as e:
    # 404 表示标签页已不存在，可忽略
    if e.code != 404:
      print(f"关闭 {tab_id} 失败:", e, file=sys.stderr)


def main():
  if len(sys.argv) != 3 or sys.argv[1] != "close":
    print("用法: python chrome_ctrl.py close '<regex>'", file=sys.stderr)
    sys.exit(1)

  pattern = re.compile(sys.argv[2])
  tabs = get_tabs()
  closed = 0

  for tab in tabs:
    url = tab.get("url", "")
    if pattern.search(url) and tab.get("type", "") == "page":
      close_tab(tab["id"])
      closed += 1
      print(f"关闭: {url}")

  print(f"共关闭 {closed} 个标签页")


if __name__ == "__main__":
  main()
#+end_src

** wallpaper
:PROPERTIES:
:CUSTOM_ID: eb675a6c-e3fc-445e-a6ab-992ec7e5a7fd
:END:
#+begin_src py :mkdirp t :tangle (zr-org-by-tangle-dir "wallpaper.py")
from __future__ import annotations

import argparse
import json
import logging
import os
import platform
import re
import shutil
import subprocess
import sys
import time
import urllib.error
import urllib.parse
import urllib.request

from dataclasses import dataclass
from pathlib import Path
from typing import Any, Optional

DEFAULT_API_BASE = "https://api.mossia.top/duckMo"
DEFAULT_PROXY = "i.pixiv.re"
DEFAULT_SIZE = "original"
USER_AGENT = "mossia-wallpaper/0.1 (+https://api.mossia.top)"

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class PixivImage:
    pid: int
    title: str
    author: str
    width: int
    height: int
    ext: str
    urls: dict[str, str]

def is_termux() -> bool:
    # 用户需求：TERMUX__HOME 可用于判定 Termux(Android)
    is_termux_env = bool(os.environ.get("TERMUX__HOME"))
    logger.debug("is_termux=%s", is_termux_env)
    return is_termux_env



def detect_default_orientation() -> str:
    # 需求：自动检测操作系统决定横/竖屏
    # 用户补充：Android/Termux 只需要竖屏
    if is_termux():
        logger.debug("detect_default_orientation: termux -> portrait")
        return "portrait"

    # 其他 OS 默认横屏（桌面环境通常是横向显示器）
    logger.debug("detect_default_orientation: non-termux -> landscape")
    return "landscape"


def orientation_to_image_size_type(orientation: str) -> int:
    mapping = {
        "landscape": 1,
        "portrait": 2,
        "square": 3,
    }
    try:
        image_size_type = mapping[orientation]
    except KeyError as exc:
        logger.debug("orientation_to_image_size_type: unsupported orientation=%s", orientation)
        raise ValueError(f"Unsupported orientation: {orientation}") from exc

    logger.debug(
        "orientation_to_image_size_type: orientation=%s imageSizeType=%s",
        orientation,
        image_size_type,
    )
    return image_size_type


def http_post_json(url: str, payload: dict[str, Any], timeout_sec: int) -> dict[str, Any]:
    logger.debug("http_post_json: url=%s timeout=%ss payload=%s", url, timeout_sec, payload)

    body = json.dumps(payload, ensure_ascii=False).encode("utf-8")
    req = urllib.request.Request(url, data=body, method="POST")
    req.add_header("Content-Type", "application/json")
    req.add_header("Accept", "application/json")
    req.add_header("User-Agent", USER_AGENT)

    try:
        with urllib.request.urlopen(req, timeout=timeout_sec) as resp:
            raw = resp.read()
            charset = resp.headers.get_content_charset() or "utf-8"
            text = raw.decode(charset, errors="replace")
            logger.debug(
                "http_post_json: status=%s bytes=%s charset=%s",
                getattr(resp, "status", None),
                len(raw),
                charset,
            )
    except urllib.error.HTTPError as e:
        raw = e.read() or b""
        charset = (getattr(e, "headers", None) and e.headers.get_content_charset()) or "utf-8"
        text = raw.decode(charset, errors="replace")
        logger.debug("http_post_json: HTTPError code=%s body=%s", e.code, text[:400])
        raise RuntimeError(f"API HTTP {e.code}: {text[:400]}") from e
    except urllib.error.URLError as e:
        logger.debug("http_post_json: URLError=%s", e)
        raise RuntimeError(f"API request failed: {e}") from e

    try:
        data = json.loads(text)
    except json.JSONDecodeError as e:
        logger.debug("http_post_json: invalid_json=%s", text[:400])
        raise RuntimeError(f"API returned invalid JSON: {text[:400]}") from e

    return data


def parse_pixiv_image(payload: dict[str, Any]) -> PixivImage:
    logger.debug(
        "parse_pixiv_image: success=%s errCode=%s message=%s",
        payload.get("success"),
        payload.get("errCode"),
        payload.get("message"),
    )
    if not payload.get("success"):
        raise RuntimeError(
            f"API error: errCode={payload.get('errCode')} message={payload.get('message')}"
        )

    data = payload.get("data")
    if not isinstance(data, list) or not data:
        raise RuntimeError("API returned empty data")

    item = data[0]
    if not isinstance(item, dict):
        raise RuntimeError("API returned unexpected data item")

    urls: dict[str, str] = {}
    urls_list = item.get("urlsList")
    if isinstance(urls_list, list):
        for u in urls_list:
            if not isinstance(u, dict):
                continue
            size = u.get("urlSize")
            url = u.get("url")
            if isinstance(size, str) and isinstance(url, str):
                urls[size] = url

    def as_int(x: Any) -> int:
        try:
            return int(x)
        except Exception:
            return 0

    def as_str(x: Any) -> str:
        return x if isinstance(x, str) else ""

    image = PixivImage(
        pid=as_int(item.get("pid")),
        title=as_str(item.get("title")),
        author=as_str(item.get("author")),
        width=as_int(item.get("width")),
        height=as_int(item.get("height")),
        ext=as_str(item.get("ext")),
        urls=urls,
    )
    logger.debug(
        "parse_pixiv_image: pid=%s author=%s title=%s size=%sx%s ext=%s urls=%s",
        image.pid,
        image.author,
        image.title,
        image.width,
        image.height,
        image.ext,
        sorted(image.urls.keys()),
    )
    return image


def choose_url(image: PixivImage, preferred_size: str) -> str:
    available_sizes = sorted(image.urls.keys())
    if preferred_size in image.urls:
        logger.debug(
            "choose_url: preferred=%s chosen (available=%s)",
            preferred_size,
            available_sizes,
        )
        return image.urls[preferred_size]

    for fallback in ("original", "regular", "small", "thumb", "mini"):
        if fallback in image.urls:
            logger.debug(
                "choose_url: preferred=%s fallback=%s (available=%s)",
                preferred_size,
                fallback,
                available_sizes,
            )
            return image.urls[fallback]

    if image.urls:
        chosen = next(iter(image.urls.values()))
        logger.debug(
            "choose_url: preferred=%s fallback=first (available=%s)",
            preferred_size,
            available_sizes,
        )
        return chosen

    raise RuntimeError("No image URLs returned by API")


def infer_suffix(url: str, fallback_ext: str) -> str:
    parsed = urllib.parse.urlparse(url)
    suffix = Path(parsed.path).suffix
    if suffix:
        logger.debug("infer_suffix: from_url=%s", suffix)
        return suffix

    if fallback_ext:
        ext = fallback_ext if fallback_ext.startswith(".") else f".{fallback_ext}"
        if len(ext) <= 10:
            logger.debug("infer_suffix: from_ext=%s", ext)
            return ext

    logger.debug("infer_suffix: fallback=.jpg")
    return ".jpg"


def download_file(url: str, dest_path: Path, timeout_sec: int) -> None:
    dest_path.parent.mkdir(parents=True, exist_ok=True)
    tmp_path = dest_path.with_suffix(dest_path.suffix + ".part")

    logger.debug(
        "download_file: url=%s dest=%s tmp=%s timeout=%ss",
        url,
        dest_path,
        tmp_path,
        timeout_sec,
    )

    req = urllib.request.Request(url, method="GET")
    req.add_header("User-Agent", USER_AGENT)

    started = time.time()
    total_bytes = 0
    try:
        with urllib.request.urlopen(req, timeout=timeout_sec) as resp, tmp_path.open("wb") as f:
            while True:
                chunk = resp.read(1024 * 128)
                if not chunk:
                    break
                f.write(chunk)
                total_bytes += len(chunk)
    except Exception as e:
        logger.debug("download_file failed: %s", e)
        try:
            if tmp_path.exists():
                tmp_path.unlink()
        finally:
            raise

    tmp_path.replace(dest_path)
    elapsed = time.time() - started
    logger.debug(
        "download_file: done bytes=%s elapsed=%.2fs dest=%s",
        total_bytes,
        elapsed,
        dest_path,
    )


def termux_set_wallpaper(image_path: Path, *, lockscreen: bool, both: bool) -> None:
    logger.debug(
        "termux_set_wallpaper: image_path=%s lockscreen=%s both=%s",
        image_path,
        lockscreen,
        both,
    )

    if not shutil.which("termux-wallpaper"):
        raise RuntimeError(
            "termux-wallpaper not found. Install Termux:API app and run: pkg install termux-api"
        )

    if both:
        cmd1 = ["termux-wallpaper", "-f", str(image_path)]
        cmd2 = ["termux-wallpaper", "-l", "-f", str(image_path)]
        logger.debug("termux_set_wallpaper: run %s", cmd1)
        subprocess.run(cmd1, check=True)
        logger.debug("termux_set_wallpaper: run %s", cmd2)
        subprocess.run(cmd2, check=True)
        return

    cmd = ["termux-wallpaper", "-f", str(image_path)]
    if lockscreen:
        cmd.insert(1, "-l")
    logger.debug("termux_set_wallpaper: run %s", cmd)
    subprocess.run(cmd, check=True)


def windows_set_wallpaper(image_path: Path) -> None:
    import ctypes
    from ctypes import wintypes

    abs_path = str(image_path.expanduser().resolve())
    if not Path(abs_path).is_file():
        raise RuntimeError(f"Image file not found: {abs_path}")

    SPI_SETDESKWALLPAPER = 0x0014
    SPIF_UPDATEINIFILE = 0x01
    SPIF_SENDCHANGE = 0x02

    user32 = ctypes.WinDLL("user32", use_last_error=True)
    SystemParametersInfoW = user32.SystemParametersInfoW
    SystemParametersInfoW.argtypes = (
        wintypes.UINT,
        wintypes.UINT,
        wintypes.LPWSTR,
        wintypes.UINT,
    )
    SystemParametersInfoW.restype = wintypes.BOOL

    buf = ctypes.create_unicode_buffer(abs_path)
    ok = SystemParametersInfoW(
        SPI_SETDESKWALLPAPER,
        0,
        buf,
        SPIF_UPDATEINIFILE | SPIF_SENDCHANGE,
    )
    if not ok:
        raise ctypes.WinError(ctypes.get_last_error())


def set_wallpaper(image_path: Path, *, lockscreen: bool, both: bool) -> None:
    logger.debug(
        "set_wallpaper: image_path=%s lockscreen=%s both=%s",
        image_path,
        lockscreen,
        both,
    )

    if is_termux():
        logger.debug("set_wallpaper: using termux-wallpaper")
        termux_set_wallpaper(image_path, lockscreen=lockscreen, both=both)
        return

    system = platform.system()
    logger.debug("set_wallpaper: platform.system()=%s", system)
    if system == "Windows":
        if lockscreen or both:
            raise RuntimeError(
                "Windows lockscreen wallpaper is not implemented. "
                "Please omit --lockscreen/--both (desktop wallpaper only)."
            )
        windows_set_wallpaper(image_path)
        return

    raise RuntimeError(
        f"Wallpaper setting not implemented for {system}. Use --download-only to just fetch the image."
    )


def default_download_dir() -> Path:
    xdg_cache = os.environ.get("XDG_CACHE_HOME")
    if xdg_cache:
        return Path(xdg_cache) / "mossia-wallpaper"
    return Path.home() / ".cache" / "mossia-wallpaper"


_CACHE_IMAGE_NAME_RE = re.compile(
    r"^\d{8}_\d{6}_pid\d+_(landscape|portrait|square)_(original|regular|small|thumb|mini)\.[^./\\]+$"
)


def _is_generated_image_file(path: Path) -> bool:
    return bool(_CACHE_IMAGE_NAME_RE.match(path.name))


def cleanup_download_dir(download_dir: Path, *, keep: int, protect_paths: set[Path]) -> int:
    logger.debug(
        "cleanup_download_dir: dir=%s keep=%s protect_paths=%s",
        download_dir,
        keep,
        sorted(str(p) for p in protect_paths),
    )

    if keep < 0:
        raise ValueError("keep must be >= 0")

    download_dir = download_dir.expanduser()
    if not download_dir.is_dir():
        logger.debug("cleanup_download_dir: dir not found -> skip")
        return 0

    protect_resolved: set[Path] = set()
    for p in protect_paths:
        try:
            protect_resolved.add(p.expanduser().resolve())
        except Exception:
            protect_resolved.add(p)

    deleted = 0
    now = time.time()
    stale_part_sec = 60 * 60

    cache_files: list[Path] = []
    stale_part_files: list[Path] = []

    for child in download_dir.iterdir():
        if not child.is_file():
            continue

        if child.name.endswith(".part"):
            base = child.with_suffix("")
            if _is_generated_image_file(base):
                stale_part_files.append(child)
            continue

        if keep != 0 and _is_generated_image_file(child):
            cache_files.append(child)

    for p in stale_part_files:
        try:
            mtime = p.stat().st_mtime
        except OSError:
            continue
        if now - mtime < stale_part_sec:
            continue
        try:
            p.unlink()
            deleted += 1
        except OSError:
            pass

    if keep == 0:
        logger.debug("cleanup_download_dir: deleted=%s (keep=0)", deleted)
        return deleted

    sortable: list[tuple[float, str, Path]] = []
    for p in cache_files:
        try:
            sortable.append((p.stat().st_mtime, p.name, p))
        except OSError:
            continue
    sortable.sort(key=lambda item: (item[0], item[1]), reverse=True)
    sorted_files = [p for _, _, p in sortable]

    keep_set: set[Path] = set()
    for p in sorted_files[:keep]:
        try:
            keep_set.add(p.expanduser().resolve())
        except Exception:
            keep_set.add(p)

    for p in sorted_files[keep:]:
        try:
            resolved = p.expanduser().resolve()
        except Exception:
            resolved = p
        if resolved in keep_set or resolved in protect_resolved:
            continue
        try:
            p.unlink()
            deleted += 1
        except OSError:
            pass

    logger.debug("cleanup_download_dir: deleted=%s", deleted)
    return deleted


_BACKUP_DIR_NAME = "backups"


def _latest_generated_image(download_dir: Path) -> Optional[Path]:
    download_dir = download_dir.expanduser()
    if not download_dir.is_dir():
        return None

    best: Optional[tuple[float, str, Path]] = None
    try:
        for child in download_dir.iterdir():
            if not child.is_file():
                continue
            if not _is_generated_image_file(child):
                continue
            try:
                st = child.stat()
            except OSError:
                continue
            candidate = (st.st_mtime, child.name, child)
            if best is None or candidate > best:
                best = candidate
    except OSError:
        return None

    return best[2] if best is not None else None


def _backup_file(src: Path, backup_dir: Path) -> Optional[Path]:
    src = src.expanduser()
    if not src.is_file():
        return None

    backup_dir = backup_dir.expanduser()
    backup_dir.mkdir(parents=True, exist_ok=True)

    ts = time.strftime("%Y%m%d_%H%M%S")
    dest = backup_dir / f"{ts}_{src.name}"

    if dest.exists():
        for i in range(1, 1000):
            candidate = backup_dir / f"{ts}_{i}_{src.name}"
            if not candidate.exists():
                dest = candidate
                break

    shutil.copy2(src, dest)
    return dest


def build_arg_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description="Fetch image from mossia API and set as wallpaper")
    p.add_argument("--api", default=os.environ.get("MOSSIA_API_BASE", DEFAULT_API_BASE))
    p.add_argument("--proxy", default=DEFAULT_PROXY)
    p.add_argument(
        "--size",
        default=DEFAULT_SIZE,
        choices=["original", "regular", "small", "thumb", "mini"],
        help="Desired image size from urlsList",
    )
    p.add_argument(
        "--orientation",
        default="auto",
        choices=["auto", "portrait", "landscape", "square"],
        help="auto: decide by OS (Termux=portrait, others=landscape)",
    )
    p.add_argument(
        "--r18-type",
        type=int,
        default=0,
        choices=[0, 1],
        help="0: non-r18 (default), 1: r18",
    )
    p.add_argument("--timeout", type=int, default=25)
    p.add_argument("--debug", action="store_true", help="Enable debug logging to stderr")
    p.add_argument("--download-dir", type=Path, default=default_download_dir())
    p.add_argument(
        "--cache-keep",
        type=int,
        default=10,
        help="Keep at most N generated images in download dir (0 = keep all)",
    )
    p.add_argument(
        "--backup-current",
        action="store_true",
        help="Backup previous wallpaper image before setting a new one",
    )
    p.add_argument(
        "--backup-dir",
        type=Path,
        default=None,
        help="Directory to store backups (default: <download-dir>/backups)",
    )
    p.add_argument("--output", type=Path, default=None, help="Write to exact file path")
    p.add_argument("--download-only", action="store_true", help="Do not set wallpaper")
    p.add_argument("--dry-run", action="store_true", help="Print selected URL and exit")

    lock_group = p.add_mutually_exclusive_group()
    lock_group.add_argument("--lockscreen", action="store_true", help="Set lockscreen wallpaper")
    lock_group.add_argument("--both", action="store_true", help="Set both home+lockscreen")

    return p


def main(argv: list[str]) -> int:
    args = build_arg_parser().parse_args(argv)

    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.WARNING,
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
        datefmt="%H:%M:%S",
    )
    logger.debug("args=%s", args)

    if args.orientation == "auto":
        orientation = detect_default_orientation()
    else:
        orientation = args.orientation

    image_size_type = orientation_to_image_size_type(orientation)
    logger.debug("selected orientation=%s imageSizeType=%s", orientation, image_size_type)

    request_payload: dict[str, Any] = {
        "num": 1,
        "proxy": args.proxy,
        "sizeList": [args.size],
        "imageSizeType": image_size_type,
        "r18Type": args.r18_type,
    }
    logger.debug(
        "API request: api=%s payload=%s timeout=%ss",
        args.api,
        request_payload,
        args.timeout,
    )

    resp = http_post_json(args.api, request_payload, timeout_sec=args.timeout)
    image = parse_pixiv_image(resp)
    url = choose_url(image, args.size)
    logger.debug("selected url=%s", url)

    if args.dry_run:
        print(f"orientation={orientation} imageSizeType={image_size_type}")
        print(f"pid={image.pid} author={image.author} title={image.title}")
        print(url)
        return 0

    if args.output is not None:
        out_path = args.output
        out_path.parent.mkdir(parents=True, exist_ok=True)
        logger.debug("output path (explicit)=%s", out_path)
    else:
        suffix = infer_suffix(url, image.ext)
        ts = time.strftime("%Y%m%d_%H%M%S")
        out_path = args.download_dir / f"{ts}_pid{image.pid}_{orientation}_{args.size}{suffix}"
        logger.debug("output path (generated)=%s", out_path)

    if args.backup_current and not args.download_only:
        backup_dir = args.backup_dir
        if backup_dir is None:
            backup_dir = args.download_dir / _BACKUP_DIR_NAME
        logger.debug("backup_current enabled: backup_dir=%s", backup_dir)

        if args.output is not None and out_path.exists():
            previous_path = out_path
        else:
            previous_path = _latest_generated_image(args.download_dir)
        logger.debug("backup_current: previous_path=%s", previous_path)

        if previous_path is not None:
            try:
                backup_path = _backup_file(previous_path, backup_dir)
            except OSError as e:
                print(f"Backup failed: {e}", file=sys.stderr)
            else:
                if backup_path is not None:
                    print(f"Backed up: {backup_path}", file=sys.stderr)
    logger.debug("download start")
    download_file(url, out_path, timeout_sec=args.timeout)


    print(f"Saved: {out_path}")
    print(f"pid={image.pid} author={image.author} title={image.title}")

    if args.download_only:
        if args.output is None:
            deleted = cleanup_download_dir(
                args.download_dir,
                keep=args.cache_keep,
                protect_paths={out_path},
            )
            if deleted:
                print(f"Cleaned {deleted} old files in {args.download_dir}", file=sys.stderr)
        return 0
    logger.debug("set wallpaper")
    set_wallpaper(out_path, lockscreen=args.lockscreen, both=args.both)



    if args.output is None:
        deleted = cleanup_download_dir(
            args.download_dir,
            keep=args.cache_keep,
            protect_paths={out_path},
        )
        if deleted:
            print(f"Cleaned {deleted} old files in {args.download_dir}", file=sys.stderr)

    print("Wallpaper updated")
    return 0


if __name__ == "__main__":
    try:
        raise SystemExit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        raise SystemExit(130)
#+end_src
