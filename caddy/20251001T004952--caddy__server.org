#+title:      caddy
#+date:       [2025-10-01 Wed 00:49]
#+filetags:   :server:
#+identifier: 20251001T004952

* tangle
#+begin_src elisp tangle
(let* ((name (pcase system-type
               ('windows-nt "windows-amd64")
               ('android "linux-arm64")
               ('gnu/linux "linux-amd64")))
       (zr-local-pls (plstore-open "../.global.pls"))
       (caddy-proxy (cdr (plstore-get zr-local-pls "caddy-proxy")))
       (zr-local-pls (plstore-open "caddy.pls"))
       (local-conf-dir (expand-file-name "_local"))
       (tangle-dir (expand-file-name "_tangle/"))
       (url (format "https://github.com/kkkykin/custom-caddy/releases/latest/download/caddy-%s.tar.gz" name)))
  (mkdir tangle-dir t)
  (dolist (sub '("subpath" "global" "l4" "snippets"))
    (let ((sub-dir (expand-file-name sub local-conf-dir)))
      (mkdir sub-dir t)
      (write-region "# placeholder" nil
                    (expand-file-name "_placeholder.Caddyfile" sub-dir))))
  (org-babel-tangle))
#+end_src

* env
:PROPERTIES:
:CUSTOM_ID: 799e1881-69a9-45e3-ab2d-05b6a0ea8d80
:END:
#+header: :var localpath=(concat local-conf-dir)
#+header: :var mainpath=(expand-file-name "main" tangle-dir)
#+header: :var listen=(if (eq 'android system-type) "6680" "80")
#+begin_src org :tangle (zr-org-by-tangle-dir "env")
LISTEN=$listen
LOCALPATH=$localpath
MAINPATH=$mainpath
#+end_src
* config
:PROPERTIES:
:header-args:caddy: :mkdirp t
:CUSTOM_ID: 54b08ed4-dcf7-4fe4-86e4-742d9bdc42d4
:END:

#+begin_src caddy :tangle (zr-org-by-tangle-dir "Caddyfile")
{
    import {$LOCALPATH}/global/*
    import {$MAINPATH}/global/*
}

import {$LOCALPATH}/snippets/*
import {$MAINPATH}/snippets/*

:{$LISTEN} {
    import {$MAINPATH}/subpath/*
    import {$LOCALPATH}/subpath/*
}
#+end_src
** main
:PROPERTIES:
:CUSTOM_ID: 5297ab0f-3f8b-4b59-b5af-c29366d57a64
:END:
*** global
:PROPERTIES:
:tangle-dir: _tangle/main/global
:CUSTOM_ID: 87e8d3b9-696c-4dc0-b041-6ab479876b29
:END:
#+begin_src caddy :tangle (zr-org-by-tangle-dir "misc.Caddyfile")
order coraza_waf first
order random_file before reverse_proxy
order aria2_middleware before reverse_proxy
auto_https disable_redirects
#+end_src

#+begin_src caddy :tangle (zr-org-by-tangle-dir "servers.Caddyfile")
servers {
    trusted_proxies static private_ranges
    trusted_proxies_strict
}
#+end_src

#+begin_src caddy :tangle (zr-org-by-tangle-dir "l4.Caddyfile")
layer4 {
    :1{$LISTEN} {
        import {$LOCALPATH}/l4/*
    }
}
#+end_src

*** snippets
:PROPERTIES:
:tangle-dir: _tangle/main/snippets
:END:
**** load balance
:PROPERTIES:
:CUSTOM_ID: 072fe3c4-fc1a-44e0-8ccc-64a9630ca915
:END:
#+begin_src caddy :tangle (zr-org-by-tangle-dir "lb.Caddyfile")
(common_lb) {
    {block}
    # 1) 负载均衡：首选 least_conn（资源最闲节点），
    #    如果所有节点都满了就退回 random，保证一定能选出节点。
    lb_policy least_conn {
        fallback random
    }

    # 2) Passive Health-Check —— 关键三行
    fail_duration          30s     # 30 秒内出现失败记录都视为“污点”
    max_fails              3       # 连续 3 次失败才踢掉（避免偶发抖动）
    unhealthy_latency      2s      # 响应超过 2s 也算一次失败

    # 3) 重试（配合健康检测才有意义）
    lb_retries             2       # 最多重试 2 次
    lb_try_duration        5s      # 整体等待上限 5s
    lb_try_interval        200ms   # 每次重试间隔
}

(slow_lb) {
    {blocks.main}
    # 1. 负载均衡：轮询，简单公平
    lb_policy round_robin

    # 2. 被动健康检查 —— 放大版
    fail_duration          120s
    max_fails              2
    unhealthy_latency      18s
    unhealthy_status       3xx 4xx 5xx

    # 3. 重试
    lb_try_duration        {args[0]}
    lb_retry_match         method GET HEAD

    # 4. 传输超时放大
    transport http {
        {blocks.transport}
        dial_timeout                3s
        response_header_timeout     15s
        read_timeout                20s
        write_timeout               20s
    }
}
#+end_src

**** cors
:PROPERTIES:
:CUSTOM_ID: b90c38da-1fce-4fef-8f9f-6414994fd6ea
:END:
#+begin_src caddy :tangle (zr-org-by-tangle-dir "cors.Caddyfile")
(cors) {
    map {header.Origin} {cors_ok} {
        {blocks.map}
        default                     0
    }
    @corsPreflight {
        method OPTIONS
        expression `{cors_ok} == "1"`
    }
    @allowed {
        expression `{cors_ok} == "1"`
        {blocks.allow}
    }

    handle @corsPreflight {
        header {
            Access-Control-Allow-Origin "{header.Origin}"
            Access-Control-Allow-Methods "{args[0]}"
            Access-Control-Allow-Headers "{args[1]}"
            Access-Control-Allow-Credentials "true"
            Vary "Origin"
        }
        respond "" 204
    }

    handle @allowed {
        header {
            Access-Control-Allow-Origin "{header.Origin}"
            Access-Control-Allow-Credentials "true"
            Vary "Origin"
        }
    }
}
#+end_src

**** remove forward headers
:PROPERTIES:
:CUSTOM_ID: f60abfad-d6df-40a6-98b8-e5be1198a108
:END:
#+begin_src caddy :tangle (zr-org-by-tangle-dir "remove-forward-headers.Caddyfile")
(remove-forward-headers) {
    header_up -Cdn-Loop
    header_up -Cf-*
    header_up -X-Forwarded-*
    header_up -X-Real-IP
    header_up -Via
}
#+end_src

**** rate limit
#+begin_src caddy
(rate-limit-by-key) {
    rate_limit {
        zone dynamic_limit {
            key    "{args[0]}"
            window "{args[1]}"
            events {args[2]}
        }
    }
}
#+end_src

**** waf
#+begin_src caddy
(waf) {
    coraza_waf {
        load_owasp_crs
        directives `
        Include @coraza.conf-recommended
        Include @crs-setup.conf.example
        Include @owasp_crs/*.conf
        SecRuleEngine On
        `
    }
}
#+end_src

** subpath
:PROPERTIES:
:tangle-dir: _tangle/main/subpath
:END:

*** mpv
:PROPERTIES:
:CUSTOM_ID: 54913f3d-72e8-45ba-b9fe-8b9bb6599582
:END:
#+begin_src caddy :mkdirp t :tangle (zr-org-by-tangle-dir "mpv.Caddyfile")
basic_auth /mpv/ {
    mpv $2a$14$ZCw3mfpECp3awIyQNk33.eTTs/DTr3Hkle8dXzGQ7IT.sE48UA/3S
}
route /mpv/ {
    import cors "POST, OPTIONS" "Content-Type, Authorization, Origin" {
        map {
            <<cors-map()>>
        }
        allow {
            client_ip 127.0.0.1/32
            method POST
            header Content-Type application/json
        }
    }
    exec @allowed {
        command mpv
        args --playlist=- --terminal=no --input-ipc-server=\\.\pipe\mpv-caddy
    }
}
#+end_src

*** pac
:PROPERTIES:
:CUSTOM_ID: 9d031bef-33c9-4fe8-aee8-31fb9a29d1fc
:END:
#+header: :var pac_dir=(expand-file-name "../surfingkeys/_tangle")
#+begin_src caddy :tangle (zr-org-by-tangle-dir "pac.Caddyfile")
handle /pac.js {
    root * "$pac_dir"
    file_server
}
#+end_src

*** browse-url
:PROPERTIES:
:CUSTOM_ID: 96e9671c-2992-4c32-94e9-435f82f60950
:END:
#+begin_src caddy :mkdirp t :tangle (zr-org-by-tangle-dir "browse-url.Caddyfile")
basic_auth /browse-url/ {
    browse $2a$14$fDztUDUJKeJtmvWWYlD2Vuvtsdn.9/HsF/V.YkdYMItdnepA31JZC
}
route /browse-url/ {
    import cors "GET, OPTIONS" "Authorization, Origin, url" {
        map {
            <<cors-map(cors="browse-url-cors")>>
        }
        allow {
            client_ip 127.0.0.1/32
            header url http*
            method GET
        }
    }
    exec @allowed {
        command explorer
        args "{header.url}"
    }
}
#+end_src

*** rsshub
:PROPERTIES:
:CUSTOM_ID: cc962bac-3d8f-428e-b0ce-b31541933960
:END:
#+begin_src caddy :mkdirp t :tangle (zr-org-by-tangle-dir "rsshub.Caddyfile")
handle_path /rsshub/* {
    reverse_proxy <<rsshub-upstreams()>> https://rsshub-vercel-rss3.vercel.app https://rsshub-vercel-wine.vercel.app {
        header_up Host {upstream_hostport}
        header_up -X-Forwarded-*
        header_up -via

        import slow_lb 120s {
            main {
                health_uri      /healthz
                health_interval 5m
                health_body     ok
            }
            transport {
                network_proxy url http://127.0.0.1:10807
            }
        }
    }
}
#+end_src

*** aria2
:PROPERTIES:
:CUSTOM_ID: c88e06a5-88ea-4ebf-934a-9a9b5be4e002
:END:
#+begin_src caddy :mkdirp t :tangle (zr-org-by-tangle-dir "aria2.Caddyfile")
handle_path /aria2-jsonrpc {
    rewrite * /jsonrpc
    @json header content-type application/json
    json_parse @json {
      # Transform aria2.addUri params whether or not a secret token is present.
      # URIs can be at params.0 (no token) or params.1 (with token).
      transform_array params.0 ^https://pixeldrain\.com/(.*) "$0" "https://habitica-assets.kkky.eu.org/$0" when size({json.params}) == 2
      transform_array params.1 ^https://pixeldrain\.com/(.*) "$0" "https://habitica-assets.kkky.eu.org/$0" when size({json.params}) == 3

      # Add per-server options based on URI patterns.
      merge_if_match params.0 ^https?://[^/]+\.baidu(?:pcs)?\.com/file/ params.1 {"max-connection-per-server":"2"} when size({json.params}) == 2
      merge_if_match params.1 ^https?://[^/]+\.baidu(?:pcs)?\.com/file/ params.2 {"max-connection-per-server":"2"} when size({json.params}) == 3

      merge_if_match params.0 ^https://[^/]+\.mypikpak\.com/ params.1 {"max-connection-per-server":"2"} when size({json.params}) == 2
      merge_if_match params.1 ^https://[^/]+\.mypikpak\.com/ params.2 {"max-connection-per-server":"2"} when size({json.params}) == 3

      merge_if_match params.0 ^https://pixeldrain\.com/ params.1 {"max-connection-per-server":"1"} when size({json.params}) == 2
      merge_if_match params.1 ^https://pixeldrain\.com/ params.2 {"max-connection-per-server":"1"} when size({json.params}) == 3
    }
    reverse_proxy http://127.0.0.1:6800
}
#+end_src
* server
:PROPERTIES:
:CUSTOM_ID: c2a9e330-9166-40c1-a881-a7a9df33d308
:header-args: :mkdirp t
:tangle-dir: _tangle/server
:END:

#+name: hosts
- googleapis.com
- *.googleapis.com
- antigravity-unleash.goog
- *.googleusercontent.com

#+header: :var proxy-auth-header=(plist-get caddy-proxy :header)
#+header: :var proxy-auth-key=(plist-get caddy-proxy :key)
#+header: :var main_domain=(auth-source-pick-first-password :host "mydomain" :user "main")
#+begin_src org :tangle (zr-org-by-tangle-dir "server.env")
PROXY_AUTH_HEADER=$proxy-auth-header
PROXY_AUTH_KEY=$proxy-auth-key
MAIN_DOMAIN=$main_domain
#+end_src

#+begin_src caddy :tangle (zr-org-by-tangle-dir "server.Caddyfile")
{
    local_certs
    servers :443 {
        protocols h1 h2 h2c
    }
    on_demand_tls {
        ask http://127.0.0.1:9123/ask
    }
    layer4 {
        :853 {
            @allow {
                tls sni dot.{$MAIN_DOMAIN}
                remote_ip_list /var/lib/caddy/geoip-cn.cidr.txt
            }
            route @allow {
                tls {
                    connection_policy {
                        alpn dot
                    }
                }
                proxy tcp/127.0.0.1:53
            }
        }
        :2628 {
            @cn remote_ip_list /var/lib/caddy/geoip-cn.cidr.txt
            route @cn {
                proxy {
                    upstream {
                        dial tcp/127.0.0.1:5628
                        max_connections 5
                    }
                }
            }
        }
    }
}

(allowed-proxy) {
    @allowed-proxy {
        <<format-matcher()>>
        # header "{$PROXY_AUTH_HEADER}" "{$PROXY_AUTH_KEY}"
    }
}

(reverse-main-common) {
    header_up Host {http.request.host}

    header_up -X-Forwarded-*
    header_up -X-Real-IP
    header_up "-{$PROXY_AUTH_HEADER}"

    # 性能优化：低延迟模式（禁用缓冲）
    flush_interval -1
}

(reverse-trans-common) {
    resolvers 8.8.8.8 1.1.1.1

    # 增大缓冲区以提高传输性能
    read_buffer  4MB                      # 读缓冲区：4MB（适合大文件传输）
    write_buffer 4MB                      # 写缓冲区：4MB（减少IO操作次数）

    # 优化连接池
    keepalive 15m                         # 连接保持时间：15分钟
    keepalive_idle_conns_per_host 100    # 每个主机的空闲连接数：100
    keepalive_idle_conns 1000            # 总的空闲连接数：1000

    # 优化超时设置
    dial_timeout 5s                       # 建立连接超时：5秒（适合大多数网络环境）
    response_header_timeout 10s          # 响应头超时：10秒（等待服务器返回响应头的时间）
}

http://127.0.0.1:9123 {
    bind 127.0.0.1
    @allowed-host `query({'domain': [<<format-matcher(fmt="'%s'",sep=",")>>]})`
    respond @allowed-host 200
    respond 403
}

:443 {
	tls internal {
		on_demand
	}

	import allowed-proxy
	reverse_proxy @allowed-proxy {http.request.host}:443 {
		import reverse-main-common
		transport http {
			import reverse-trans-common
			tls
		}
	}
}

# :80 {
#     import allowed-proxy
#     reverse_proxy @allowed-proxy {http.request.host}:80 {
#         import reverse-main-common
#         transport http {
#             import reverse-trans-common
#         }
#     }
# }
#+end_src
* helper
** rsshub
#+name: rsshub-public-instance
#+begin_src elisp
(require 'dom)
(let* ((url-proxy-locator (lambda (&rest _) "PROXY 127.0.0.1:10807"))
       (page (org-file-contents "https://docs.rsshub.app/guide/instances")))
  (with-temp-buffer
    (insert page)
    (let* ((html  (libxml-parse-html-region (point-min) (point-max)))
           ;; 拿到页面里全部 tbody
           (tbodies (dom-by-tag html 'tbody))
           urls)
      (dolist (tbody tbodies)
        (dolist (tr (dom-by-tag tbody 'tr))
          ;; 每行第一个 <td>
          (when-let* ((first-td (car (dom-by-tag tr 'td)))
                      (a        (car (dom-by-tag first-td 'a)))
                      (href     (dom-attr a 'href)))
            (when (string-match-p "^https?://[^/]+/?$" href)
              (push href urls)))))
      urls)))
#+end_src

#+name: rsshub-upstreams
#+begin_src elisp :var urls=rsshub-public-instance()
(mapconcat (lambda (s) (replace-regexp-in-string "^\\(https?://[^/]+\\).*" "\\1" s)) urls " ")
#+end_src

#+name: rsshub-map
#+begin_src elisp :var urls=rsshub-public-instance()
(mapconcat
 (lambda (s)
   (let* ((url (url-generic-parse-url s))
          (filename (url-filename url))
          (host (url-host url))
          (port (url-port url)))
     (unless (member filename '("/" ""))
       (format "%s %s \"\""
               (if (member (cons (url-type url) port)
                           '(("https" . 443)
                             ("http" . 80)))
                   host
                 (format "%s:%s" host port))
               filename))))
 urls "\n")
#+end_src
** cors
#+name: cors-map
#+begin_src elisp :var cors="mpv-cors"
(mapconcat (lambda (s) (format "%s 1" s)) (plist-get (cdr (plstore-get zr-local-pls cors)) :cors) "\n")
#+end_src

** format-matcher
#+name: format-matcher
#+begin_src elisp :var fmt="host %s" val=hosts[] sep="\n"
(mapconcat (lambda (s) (format fmt s)) val sep)
#+end_src
* service
*** cidr
#+begin_src sh :shebang "#!/usr/bin/env bash" :tangle "no"
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  caddy-cidr.sh -o OUTPUT_DIR URL [URL ...]
Example:
  caddy-cidr.sh -o /var/lib/caddy/ \
    https://github.com/SagerNet/sing-geoip/raw/refs/heads/rule-set/geoip-cn.srs \
    https://github.com/SagerNet/sing-geoip/raw/refs/heads/rule-set/geoip-us.srs
EOF
}

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "Error: missing dependency: $1" >&2
    exit 1
  }
}

OUT_DIR=""
while getopts ":o:h" opt; do
  case "$opt" in
    o) OUT_DIR="$OPTARG" ;;
    h) usage; exit 0 ;;
    \?) echo "Error: invalid option: -$OPTARG" >&2; usage; exit 2 ;;
    :)  echo "Error: option -$OPTARG requires an argument" >&2; usage; exit 2 ;;
  esac
done
shift $((OPTIND - 1))

if [[ -z "${OUT_DIR}" || $# -lt 1 ]]; then
  echo "Error: -o OUTPUT_DIR and at least one URL are required." >&2
  usage
  exit 2
fi

need_cmd curl
need_cmd sing-box
need_cmd jq

mkdir -p "$OUT_DIR"

# 返回 URL 的文件名（去掉 query string）
url_basename() {
  local url="$1"
  url="${url%%\?*}"
  printf '%s' "${url##*/}"
}

for url in "$@"; do
  fname="$(url_basename "$url")"
  if [[ -z "$fname" || "$fname" == "/" ]]; then
    echo "Error: cannot determine filename from URL: $url" >&2
    exit 1
  fi

  # 如果不是 .srs，仍然允许，但文件名会照 URL 来
  srs_path="${OUT_DIR%/}/${fname}"
  base="${fname%.*}"              # 去掉最后一个扩展名（.srs）
  json_path="${OUT_DIR%/}/${base}.json"
  txt_path="${OUT_DIR%/}/${base}.cidr.txt"

  echo "==> Download: $url"
  curl -fL --retry 3 --retry-delay 1 -o "$srs_path" "$url"

  echo "==> Decompile: $srs_path -> $json_path"
  sing-box rule-set decompile "$srs_path" -o "$json_path"

  echo "==> Extract CIDR: $json_path -> $txt_path"
  # 提取所有 rules 里的 ip_cidr 数组元素，一行一个；去重；去空行
  jq -r '.. | .ip_cidr? // empty | .[]' "$json_path" \
    | awk 'NF' \
    | sort -u > "$txt_path"

  rm -f "$srs_path" "$json_path"
  echo "==> Done: $txt_path ($(wc -l < "$txt_path") lines)"
done
#+end_src

/etc/systemd/system/srs-decompile.service
#+begin_src conf-unix :tangle no
[Unit]
Description=Download sing-box srs and decompile to cidr text for Caddy

[Service]
Type=oneshot
User=caddy
Group=caddy

Environment="PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

ExecStart=/usr/local/bin/caddy-cidr.sh -o /var/lib/caddy/ \
  https://github.com/SagerNet/sing-geoip/raw/refs/heads/rule-set/geoip-cn.srs \
  https://github.com/Chocolate4U/Iran-sing-box-rules/raw/refs/heads/rule-set/geoip-cloudflare.srs
#+end_src

/etc/systemd/system/srs-decompile.timer
#+begin_src conf-unix :tangle no
[Unit]
Description=Run srs-decompile every 12 hours

[Timer]
OnBootSec=5min
OnUnitActiveSec=12h
Persistent=true

RandomizedDelaySec=30min
AccuracySec=1min

[Install]
WantedBy=timers.target
#+end_src

#+begin_src sh :eval no
sudo systemctl daemon-reload
sudo systemctl enable --now srs-decompile.timer
sudo systemctl status srs-decompile.timer
#+end_src
